% !TeX program = lualatex
\documentclass[12pt,a4paper]{book}

% --- Grundpakete ---
\usepackage{fontspec}              % Unicode & Systemfonts (LuaLaTeX)
\usepackage[ngerman]{babel}        % Deutsche Sprache
\usepackage{amsmath,amssymb}       % Mathematische Symbole
\usepackage{graphicx}              % Bilder einf√ºgen
\usepackage{listings}              % Quellcode-Umgebung
\usepackage{xcolor}                % Farben (statt 'color')
\usepackage{hyperref}              % klickbare Links
\usepackage{geometry}              % Seitenr√§nder
\geometry{a4paper, margin=2.5cm}
\usepackage{float}                 % f√ºr [H]

\usepackage{tikz}
\usetikzlibrary{arrows.meta,calc,positioning}


\usepackage{titlesec}
\titleformat{\paragraph}[block]{\normalfont\normalsize\bfseries}{}{0pt}{}
\titlespacing*{\paragraph}{0pt}{1ex}{0.5ex}

% --- Schriften & Fallbacks (robust, mit IfFontExists) ---
% Hauptschrift: Noto Serif -> DejaVu Serif -> Latin Modern
\IfFontExistsTF{Noto Serif}{\setmainfont{Noto Serif}}{%
	\IfFontExistsTF{DejaVu Serif}{\setmainfont{DejaVu Serif}}{\setmainfont{Latin Modern Roman}}}

% Symbol-Fallback (z.B. U+25CC)
\IfFontExistsTF{Noto Sans Symbols 2}
{\newfontfamily\SymbolsFallback{Noto Sans Symbols 2}[Scale=MatchLowercase]}
{\newfontfamily\SymbolsFallback{DejaVu Sans}[Scale=MatchLowercase]}

% Arabisch
\IfFontExistsTF{Noto Naskh Arabic}
{\newfontfamily\arabicfont[Script=Arabic]{Noto Naskh Arabic}}
{\IfFontExistsTF{Amiri}{\newfontfamily\arabicfont[Script=Arabic]{Amiri}}{\newfontfamily\arabicfont[Script=Arabic]{Scheherazade}}}

% CJK (Chinesisch/Japanisch/Koreanisch) ‚Äì w√§hle verf√ºgbare Variante
\IfFontExistsTF{Noto Sans CJK SC}
{\newfontfamily\cjkfont{Noto Sans CJK SC}}
{\IfFontExistsTF{Noto Sans CJK JP}{\newfontfamily\cjkfont{Noto Sans CJK JP}}{\newfontfamily\cjkfont{DejaVu Sans}}}

% Emoji (farbig, falls vorhanden) -> sonst monochrom
\IfFontExistsTF{Noto Color Emoji}
{\newfontfamily\emojifont{Noto Color Emoji}[Renderer=Harfbuzz]}
{\IfFontExistsTF{Noto Emoji}{\newfontfamily\emojifont{Noto Emoji}}{\newfontfamily\emojifont{DejaVu Sans}}}

% Hilfsbefehle (z. B. dotted circle / kombinierender Akut)
\newcommand{\dottedcircle}{{\SymbolsFallback ‚óå}} % U+25CC
\newcommand{\combacute}{\char"0301}              % U+0301

% --- Listings-Einstellungen ---
\lstset{
	basicstyle=\ttfamily\small,
	keywordstyle=\color{blue}\bfseries,
	commentstyle=\color{gray},
	stringstyle=\color{red},
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=single,
	breaklines=true,
	captionpos=b
}

\begin{document}

\frontmatter
\title{Informatik-Skript f√ºr die E-Phase}
\author{[Jarek Mycan]}
\date{\today}
\maketitle

\tableofcontents

\mainmatter

\chapter{Einf√ºhrung}
\section{Der Begriff Informatik}

Das Wort \textbf{Informatik} setzt sich aus zwei Teilen zusammen: \emph{Information} und \emph{Automatik}. 
Urspr√ºnglich wurde der Begriff in den 1950er Jahren in Frankreich gepr√§gt 
(\glqq informatique\grqq{}) und fand sp√§ter auch im deutschsprachigen Raum Verbreitung. 
In anderen Sprachen wird der Bereich meist \glqq Computer Science\grqq{} genannt, 
was die technische Seite st√§rker betont. 

\subsection{Information}
Der erste Bestandteil, \emph{Information}, bezieht sich auf Daten, die eine Bedeutung tragen. 
Information ist also nicht einfach nur eine Ansammlung von Zeichen oder Zahlen, 
sondern sie entsteht erst durch die \emph{Interpretation} von Daten in einem bestimmten Kontext.  
Beispielsweise ist die Zahl \glqq 42\grqq{} zun√§chst nur ein einzelner Wert.
Wird sie jedoch im Zusammenhang mit einer Temperaturangabe, einem Alter oder einem Ergebnis verstanden, wird daraus eine Information.  
Die Informatik besch√§ftigt sich also damit, Informationen \emph{darzustellen}, 
\emph{zu speichern}, \emph{zu √ºbertragen} und \emph{zu verarbeiten}.

\subsection{Automatik}
Der zweite Bestandteil, \emph{Matik} (von Automatik), bedeutet, dass diese Informationsverarbeitung 
durch Maschinen ‚Äì insbesondere Computer ‚Äì automatisiert geschieht.  
Ein zentrales Ziel der Informatik ist es, Verfahren zu entwickeln, die es erm√∂glichen, 
Informationen mithilfe von Computern effizient und zuverl√§ssig zu verarbeiten. 
Dazu geh√∂ren das Erstellen von Programmen, das Entwerfen von Algorithmen 
sowie die Entwicklung von Systemen, die Informationen ohne manuelle Eingriffe verarbeiten k√∂nnen.

\section{Bedeutung der Informatik}
Die Informatik kann somit als \emph{Wissenschaft von der systematischen Verarbeitung von Informationen, insbesondere mit Hilfe von Computern}, verstanden werden. 
Sie ist nicht nur eine technische Disziplin, sondern verbindet Elemente aus 
Mathematik, Ingenieurwissenschaften, Logik und zunehmend auch Sozial- und Geisteswissenschaften. 
Heute pr√§gt die Informatik nahezu alle Bereiche des t√§glichen Lebens: 
von Smartphones und dem Internet √ºber moderne Autos bis hin zu Medizin, Wirtschaft und Wissenschaft.

\section{Was tun eigentlich Computer?}

Computer \emph{verarbeiten Daten}. Sie f√ºhren Berechnungen aus, speichern, √ºbertragen und strukturieren Daten ‚Äî aber sie ‚Äûverstehen‚Äú keine Bedeutung im menschlichen Sinn. Bedeutung (Information) entsteht erst beim Menschen (oder in einem Modell), wenn Daten in \emph{Kontext} gesetzt werden. Der Kernprozess ist daher zweistufig:

\begin{enumerate}
	\item \textbf{Repr√§sentation:} Aus \emph{Information} werden \emph{Daten}, indem wir festlegen, wie etwas als Zeichen/Zahlen (Bits) dargestellt wird.
	\item \textbf{Abstraktion:} Aus \emph{Daten} wird (wieder) \emph{Information}, indem wir Details weglassen, strukturieren und die Daten in einem Modell deuten.
\end{enumerate}

\subsection{Von Information zu Daten: Repr√§sentation}

\emph{Repr√§sentation} bedeutet: Wir legen eine \textbf{Abbildung} fest, die etwas Bedeutungsvolles (Information) in ein \textbf{Datenformat} √ºberf√ºhrt, das der Computer verarbeiten kann.
Formal kann man das als Funktion auffassen:
\[
\mathrm{rep}:\ \text{Information} \times \text{Kontext} \;\to\; \text{Daten (Bits)}.
\]


\subsection{Von Daten zu Information: Abstraktion}

\emph{Abstraktion} bedeutet: Wir \textbf{interpretieren} Daten in einem passenden Modell und \textbf{lassen Details weg}, die f√ºr die Fragestellung nicht n√∂tig sind. So entsteht Bedeutung.
Formal:
\[
\mathrm{abs}:\ \text{Daten (Bits)} \times \text{Modell/Kontext} \;\to\; \text{Information}.
\]

\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\textwidth]{info-daten.png}% ggf. Pfad anpassen
	\caption{Wechselspiel zwischen Repr√§sentation (Information ‚Üí Daten) und Abstraktion (Daten ‚Üí Information).}
	\label{fig:info-daten}
\end{figure}

\section{Bits und Bytes}

Ein \textbf{Bit} (binary digit) ist die kleinste Informationseinheit im Rechner: Es kann genau zwei Zust√§nde annehmen, meist als \texttt{0} und \texttt{1} notiert. Physikalisch werden Bits z.\,B. durch zwei Spannungsniveaus, magnetische Ausrichtungen oder Lichtimpulse realisiert.

Einzelne Bits sind f√ºr die Verarbeitung jedoch zu fein. Deshalb werden Bits zu \textbf{Gruppen} zusammengefasst und \emph{gruppenweise} gelesen/geschrieben:

\begin{itemize}
	\item \textbf{Byte} = 8 Bit (heute die gebr√§uchlichste Grundeinheit; in den meisten Architekturen zugleich die \emph{kleinste adressierbare Einheit}).
	\item \textbf{Nibble} = 4 Bit (halbes Byte; n√ºtzlich z.\,B. bei Hexadezimaldarstellungen).
	\item \textbf{Wort (Word)} = \emph{architekturabh√§ngige} Arbeitsbreite der CPU (typisch 16, 32 oder 64 Bit).
	\item \textbf{Doppelwort/Quadwort} = Vielfache der Wortbreite (z.\,B. 32/64/128 Bit).
\end{itemize}

\subsection{Wer bestimmt die Lesegruppen?}
\textbf{Hardware:} Die \emph{Register- und ALU-Breite} eines Prozessors legt fest, wie viele Bits er in einem Schritt besonders effizient verarbeiten kann (z.\,B. 32-Bit oder 64-Bit). Auch \emph{Datenbus} und \emph{Cache-Zeilengr√∂√üen} beg√ºnstigen das Holen/Speichern ganzer Bytes-, Wort- oder Mehrfach-Wort-Bl√∂cke. Moderne CPUs k√∂nnen zus√§tzlich mit Vektor\-/SIMD-Einheiten noch gr√∂√üere Pakete (z.\,B. 128/256/512 Bit) auf einmal verarbeiten.

\textbf{Software/Betriebssystem:} Damit die Hardwarebreite genutzt werden kann, muss das \emph{Betriebssystem} die Architektur unterst√ºtzen (32-Bit- oder 64-Bit-Modus, Treiber, Systembibliotheken, ABI). Ein 64-Bit-Prozessor entfaltet seine Vorteile erst vollst√§ndig mit einem 64-Bit-Betriebssystem und passenden Programmen; andernfalls arbeitet er im 32-Bit-Kompatibilit√§tsmodus.

\paragraph{Beispiele.}
\begin{itemize}
	\item \textbf{32-Bit-System:} Die CPU arbeitet effizient mit 32-Bit-W√∂rtern (z.\,B. \texttt{int32}); Zeiger/Adressen sind 32 Bit breit. Daten werden h√§ufig in 32-Bit-Schritten geladen/geschrieben, obwohl der Speicher byteweise adressiert wird.
	\item \textbf{64-Bit-System:} Register und Zeiger sind 64 Bit breit. Das System kann gr√∂√üere Zahlenbereiche adressieren und pro Schritt breitere Daten verarbeiten; trotzdem bleiben Bytes (8 Bit) die kleinste adressierbare Einheit.
\end{itemize}
\newpage
\section{Gr√∂√üe der Daten}

\begin{center}
	\begin{tabular}{r c l c l l}
		$1~\text{k}$ & = & $1024~\text{Bit}$ & = & $2^{10}$  & (k = Kilo)\\
		$1~\text{M}$ & = & $1024 \times 1024~\text{Bit}$ & = & $2^{20}$  & (M = Mega)\\
		$1~\text{G}$ & = & $1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{30}$  & (G = Giga)\\
		$1~\text{T}$ & = & $1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{40}$  & (T = Tera)\\
		$1~\text{P}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{50}$  & (P = Peta)\\
		$1~\text{E}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{60}$  & (E = Exa)\\
		$1~\text{Z}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{70}$  & (Z = Zetta)\\
		$1~\text{Y}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{80}$  & (Y = Yotta)\\
	\end{tabular}
\end{center}

\section{Textdarstellung}

\paragraph{Von ASCII zu Unicode ‚Äî warum √ºberhaupt?}
Fr√ºhe Computersysteme nutzten \textbf{ASCII} (American Standard Code for Information Interchange, 1960er Jahre). ASCII ist ein 7-Bit-Zeichensatz mit 128 Zeichen: lateinische Grundbuchstaben A‚ÄìZ/a‚Äìz, Ziffern, Satzzeichen und Steuerzeichen (z.\,B. Zeilenumbruch). F√ºr englischen Text gen√ºgte das, \emph{aber}:
Umlaute (√§, √∂, √º), Akzente (√©), das Euro-Zeichen (‚Ç¨), kyrillisch (–ñ), griechisch (Œ©), arabisch ({\arabicfont ŸÖ}), asiatische Schriften ({\cjkfont Êó•}), Emojis ({\emojifont üòä}) \emph{fehlten}.
‚Äû√©‚Äú (NFC) vs. ‚Äûe\combacute‚Äú (NFD) bzw. ‚Äûe + \dottedcircle\combacute‚Äú.
 \emph{fehlten}.


Als √úbergang entstanden viele \textbf{‚Äûerweiterte ASCII‚Äú-Codepages} (8-Bit, 256 Zeichen), z.\,B. \texttt{ISO-8859-1}, \texttt{Windows-1252}, \texttt{KOI8-R}. Jede deckte \emph{einen} Sprachraum ab. Ergebnis: Inkompatibilit√§ten (sogenanntes \emph{Mojibake}), weil dieselben Bytewerte je nach Codepage andere Zeichen bedeuten.

\textbf{Unicode} (seit 1991) l√∂st dieses Grundproblem: \emph{ein} weltweiter Zeichensatz f√ºr \emph{alle} Schriftsysteme, Symbole, technische Zeichen und Emojis. Ziel: \emph{‚ÄûJedem Zeichen ein eindeutiger Codepunkt‚Äú} ‚Äî unabh√§ngig von Sprache, Plattform oder Anwendung.

\paragraph{Begriffe sauber trennen}
\begin{itemize}
	\item \textbf{Codepunkt} (Unicode): eine Nummer in der Form \texttt{U+XXXX} (z.\,B. \texttt{U+00E4} = ‚Äû√§‚Äú, \texttt{U+20AC} = ‚Äû‚Ç¨‚Äú, \texttt{U+1F60A} = ‚Äûüòä‚Äú).
	\item \textbf{Kodierung} (Encoding): konkrete Regel, wie Codepunkte in \emph{Bytes} umgesetzt werden (z.\,B. UTF-8, UTF-16, UTF-32).
	\item \textbf{Graphem-Cluster}: was der Mensch als ‚Äûein Zeichen‚Äú wahrnimmt (z.\,B. ‚Äûe‚Äú + kombinierender Akzent \texttt{U+0301} $\to$ ‚Äû√©‚Äú, oder Familien-Emoji aus mehreren Codepunkten).
\end{itemize}

\paragraph{Wichtige Unicode-Kodierungen}
\begin{itemize}
	\item \textbf{UTF-8} (variabel, 1‚Äì4 Byte pro Codepunkt): ASCII-Zeichen bleiben 1 Byte (abw√§rtskompatibel), alle anderen werden als 2‚Äì4 Byte kodiert. Heutzutage Standard im Web, in Dateien und Schnittstellen.
	\item \textbf{UTF-16} (variabel, 2 oder 4 Byte): Basis-Mehrsprachige Ebene (BMP) meist 2 Byte; Supplement√§rzeichen (z.\,B. viele Emojis) als Surrogatpaare (4 Byte). Achtung auf Byte-Reihenfolge (\emph{Endianness}) und optionales \emph{BOM}.
	\item \textbf{UTF-32} (fix 4 Byte): einfacher, aber speicherintensiv; praktisch v.\,a. intern in manchen Systemen.
\end{itemize}

\paragraph{Historische Entwicklung in K√ºrze}
\begin{description}
	\item[1963] ASCII (7-Bit) standardisiert Grundzeichen und Steuerzeichen.
	\item[1980er] Viele 8-Bit-Codepages (\texttt{ISO-8859-x}, \texttt{Windows-125x}) ‚Äî regionale L√∂sungen, wenig kompatibel.
	\item[1991+] Unicode-Projekt: \emph{ein} universeller Zeichensatz; Trennung von \emph{Zeichen} (Codepunkte) und \emph{Kodierung} (UTFs).
	\item[2000er+] UTF-8 setzt sich global durch (Internet, Linux/Unix, moderne Apps und Protokolle).
\end{description}

\paragraph{Wie wird Unicode praktisch genutzt?}
\begin{itemize}
	\item \textbf{Dateien und Protokolle:} Textdateien, JSON, HTML, E-Mails, Datenbanken ‚Äî fast √ºberall ist UTF-8 √ºblich. Wichtig: \emph{Encoding angeben} (z.\,B. HTTP \texttt{Content-Type}, HTML \texttt{<meta charset="utf-8">}, DB-Kollation).
	\item \textbf{Betriebssysteme:} Dateinamen und Konsolen sind (je nach System) Unicode-f√§hig; moderne Terminals verstehen UTF-8.
	\item \textbf{Programmiersprachen:} Python, Java, JavaScript, C\# u.\,a. arbeiten intern mit Unicode-Zeichenketten; I/O nutzt meist UTF-8.
\end{itemize}

\chapter{Zahlensysteme}

\section{Was ist ein Zahlensystem?}
Ein \textbf{Zahlensystem} legt fest, wie Zahlen durch \emph{Ziffern} und deren \emph{Stellenwert} dargestellt werden.
In \emph{Stellenwertsystemen} (positionalen Systemen) hat jede Stelle einen Wert, der von der \emph{Basis} \(b\) abh√§ngt:
\[
(d_k d_{k-1}\ldots d_1 d_0)_b
= d_k\cdot b^{k}+d_{k-1}\cdot b^{k-1}+\ldots + d_1\cdot b^1 + d_0\cdot b^0,
\]
wobei \(0 \le d_i < b\) gilt. Beispiele: Dezimal (\(b=10\)), Bin√§r (\(b=2\)), Oktal (\(b=8\)), Hexadezimal (\(b=16\)).
Nicht-positionale Systeme (z.\,B. r√∂mische Zahlen) kennen keinen einheitlichen Stellenwert und sind f√ºr Rechenalgorithmen unpraktisch.

\section{Dezimalsystem (\(b=10\))}
Das \textbf{Dezimalsystem} nutzt die Ziffern \(0\)‚Äì\(9\).
Es ist heute \emph{weltweit das dominante System f√ºr den Alltag und das schulische Rechnen}.
Historisch h√§ngt das vermutlich mit dem Z√§hlen an zehn Fingern zusammen.
Beispiel:
\[
(5073)_{10} = 5\cdot 10^3 + 0\cdot 10^2 + 7\cdot 10^1 + 3\cdot 10^0.
\]

\section{Andere Zahlensysteme in der Welt}
\subsection*{Sexagesimalsystem (\(b=60\))}
Das \textbf{Babylonische Sexagesimalsystem} pr√§gt uns bis heute: \emph{Zeitmessung} (60\,s \(=\) 1\,min, 60\,min \(=\) 1\,h) und \emph{Winkelma√üe} (Grad‚ÄìBogenma√ü mit Minuten und Sekunden). Rechnen erfolgt im Alltag dennoch meist dezimal; die Einteilung selbst ist aber sexagesimal.

\subsection*{Vigesimalsystem (\(b=20\))}
In Teilen der Welt gab und gibt es \textbf{Zwanzigersysteme} (Basis 20).
Sprachliche Spuren finden sich z.\,B. in Zahlw√∂rtern einiger Sprachen (Restbest√§nde wie ‚Äûvier-mal-zwanzig‚Äú f√ºr 80).
Auch hier wird formal in der Schule und in modernen Anwendungen √ºberwiegend dezimal gerechnet.

\subsection*{Duodezimalsystem (\(b=12\))}
Das \textbf{Zw√∂lfersystem} hat gute Teilbarkeit (2,3,4,6). Reste davon sieht man bei Dutzend/Gro√ü, Uhren (12 Stunden), Ma√üeinheiten aus der Geschichte. F√ºr maschinelles oder schulisches Rechnen dominiert aber 10.

\subsection*{Fazit zur Frage: ‚ÄûRechnet man irgendwo ernsthaft nicht-dezimal?‚Äú}
\textbf{Menschen} rechnen heute fast √ºberall \emph{dezimal}, mit kulturellen Resten anderer Basen in speziellen Dom√§nen (Zeit, Winkel, Ma√üe).  
\textbf{Maschinen} (Computer) \emph{rechnen bin√§r}. Darauf basiert die Notwendigkeit weiterer Basen in der Informatik (Oktal/Hex als kompakte Bin√§rdarstellung).

\section{Bin√§r, Oktal, Hexadezimal ‚Äì warum in der Informatik?}
\subsection*{Bin√§rsystem (\(b=2\))}
Digitale Schaltungen kennen zwei stabile Zust√§nde (z.\,B. ‚Äûaus‚Äú/‚Äûein‚Äú). Deshalb arbeitet Hardware \emph{bin√§r}.
\[
(101010)_2 = 1\cdot 2^5 + 0\cdot 2^4 + 1\cdot 2^3 + 0\cdot 2^2 + 1\cdot 2^1 + 0\cdot 2^0 = 42.
\]

\subsection*{Oktalsystem (\(b=8\)) und Hexadezimalsystem (\(b=16\))}
Beide sind f√ºr Menschen \emph{kompakte Schreibweisen} von Bin√§rzahlen:
\begin{itemize}
	\item 1 \textbf{Oktal-Ziffer} entspricht \textbf{3 Bit} (weil \(8=2^3\)).
	\item 1 \textbf{Hex-Ziffer} entspricht \textbf{4 Bit} (weil \(16=2^4\)).
\end{itemize}
Darum lassen sich Bin√§rzahlen leicht gruppieren:
\[
\underbrace{1010}_{\text{A}}\,\underbrace{1010}_{\text{A}} = (\text{AA})_{16} = (10101010)_2.
\]
Hex ist heute Standard in Programmierung, Speicher-Dumps, Farbwerten (\#FF00AA), Adressen usw.
Oktal sieht man u.\,a. noch bei UNIX-Rechten (z.\,B. \(0755\)).

\section{Umrechnungen zwischen Basen}
\subsection*{Von Dezimal in eine Basis \(b\) (Divisionsrest-Methode)}
Beispiel: \(93_{10}\) nach Bin√§r.
\[
\begin{array}{r|l}
	93:2 = 46 \text{ Rest }1\\
	46:2 = 23 \text{ Rest }0\\
	23:2 = 11 \text{ Rest }1\\
	11:2 = 5  \text{ Rest }1\\
	5:2  = 2  \text{ Rest }1\\
	2:2  = 1  \text{ Rest }0\\
	1:2  = 0  \text{ Rest }1
\end{array}
\Rightarrow\ (93)_{10} = (1011101)_2.
\]

\subsection*{Von Basis \(b\) nach Dezimal (Horner-Schema)}
Beispiel: \((2A)_{16}\) mit \(A=10\):
\[
(2A)_{16} = 2\cdot 16^1 + 10\cdot 16^0 = 32 + 10 = 42.
\]

\subsection*{Direkt zwischen Bin√§r, Oktal, Hex}
Gruppieren in 3er- bzw. 4er-Bl√∂cke (von rechts):
\[
(110\ 010\ 111)_2 = (627)_8,\qquad
(1010\ 1111)_2 = (\text{AF})_{16}.
\]

\section{Beispiele}
\begin{center}
	\begin{tabular}{r|c|c|c}
		\textbf{Dezimal} & \textbf{Bin√§r} & \textbf{Oktal} & \textbf{Hex} \\
		\hline
		10 & \(1010\) & \(12\) & A \\
		26 & \(11010\) & \(32\) & 1A \\
		42 & \(101010\) & \(52\) & 2A \\
		64 & \(1000000\) & \(100\) & 40 \\
		100 & \(1100100\) & \(144\) & 64 \\
	\end{tabular}
\end{center}

\paragraph{Kleiner Blick √ºber den Tellerrand.}
Auch andere Basen sind m√∂glich und wurden erprobt (z.\,B. Tern√§r \(b=3\)).
F√ºr die heutige Praxis gilt: Menschen bevorzugen \(b=10\), Computer arbeiten in \(b=2\); Oktal/Hex dienen als menschenfreundliche Br√ºcke zur Bin√§rwelt, Sexagesimal und Zwanziger-/Zw√∂lfersysteme leben in speziellen Dom√§nen weiter.

\section{Die Zweierkomplementdarstellung}

\subsection{Worum geht es?}
Computer speichern Zahlen als Bitmuster. F√ºr \emph{positive} ganze Zahlen ist das einfach (normale Bin√§rdarstellung). 
Aber wie speichern wir \emph{negative} Zahlen so, dass Addieren und Subtrahieren trotzdem mit der \emph{gleichen Hardware} funktionieren?
Die Antwort ist die \textbf{Zweierkomplementdarstellung}.

\subsection{Warum verwendet man das Zweierkomplement?}
\begin{itemize}
	\item \textbf{Ein Addierwerk f√ºr alles:} Dieselbe Schaltung addiert sowohl positive als auch negative Zahlen; Subtraktion wird als ‚ÄûAddiere das Zweierkomplement‚Äú ausgef√ºhrt.
	\item \textbf{Eindeutige Null:} Es gibt nur \emph{eine} Null (anders als bei Vorzeichen-\&-Betrag oder Einerkomplement).
	\item \textbf{Einfache Regeln:} Vorzeichenverl√§ngerung (Sign Extension) ist trivial: f√ºhrende Einsen bei negativen Zahlen, Nullen bei positiven.
	\item \textbf{Sortier-/Vergleichsfreundlich:} Bei festem Wortbreite-Vergleich funktioniert das wie erwartet.
	\item \textbf{Mathematisch sauber:} Der Wertebereich ist genau \(-2^{n-1},\ldots,0,\ldots,2^{n-1}-1\) f√ºr \(n\)~Bit.
\end{itemize}

\subsection{So bildet man das Zweierkomplement (aus einer positiven Zahl \(x\))}
F√ºr eine feste Wortbreite (z.\,B. 8~Bit):
\begin{enumerate}
	\item Schreibe \(x\) bin√§r mit f√ºhrenden Nullen.
	\item \textbf{Alle Bits invertieren} (0\,\(\leftrightarrow\)\,1).
	\item \textbf{+1 addieren.}
\end{enumerate}
Beispiel: \(-5\) als 8-Bit-Zahl. \\
\(+5 = \texttt{00000101}\ \Rightarrow\) invertiert \(\texttt{11111010}\ \Rightarrow\) \(+1\) \(\Rightarrow\) \(\boxed{\texttt{11111011}}\).

\subsection*{So liest man ein Zweierkomplement-Bitmuster}
\begin{itemize}
	\item \textbf{MSB (linkestes Bit) = 0} \(\Rightarrow\) positive Zahl: normal als Bin√§rzahl lesen.
	\item \textbf{MSB = 1} \(\Rightarrow\) negative Zahl: wieder positiv machen durch \emph{invertieren + 1} und ein Minus davor.
\end{itemize}
Beispiel: \(\texttt{11101100}\) (8~Bit) \(\Rightarrow\) invertieren \(\texttt{00010011}\), \(+1\) \(\Rightarrow\) \(\texttt{00010100} = 20\) \(\Rightarrow\) Wert ist \(-20\).

\subsection*{Wertebereich}
F√ºr \(n\)~Bit gilt:
\[
\boxed{\ -2^{n-1}\ \le\ \text{Wert}\ \le\ 2^{n-1}-1\ }\quad
\text{(z.\,B. 4~Bit: \(-8\) bis \(+7\)).}
\]
Auff√§llig: Es gibt \emph{kein} \(+2^{n-1}\) (bei 4~Bit also kein \(+8\)); das Muster \(\texttt{1000}\) steht f√ºr \(-8\).

\subsection*{Rechnen mit Zweierkomplement}
\paragraph{Addition/Subtraktion.}
\begin{itemize}
	\item Subtraktion \(a-b\) wird als \(a + (\text{Zweierkomplement von } b)\) gerechnet.
	\item \emph{Beispiel (4~Bit):} \(7 + (-3)\): \(\texttt{0111} + \texttt{1101} = \texttt{1 0100}\) \(\Rightarrow\) \(\texttt{0100} = 4\) (√úbertrag links f√§llt weg).
\end{itemize}

\paragraph{√úberlauf (Overflow) erkennen.}
\begin{itemize}
	\item \textbf{Regel:} Addiert man zwei \emph{positive} Zahlen und erh√§lt eine \emph{negative}, oder zwei \emph{negative} und erh√§lt eine \emph{positive}, dann ist Overflow aufgetreten.
	\item Alternativ technisch: Overflow, wenn \emph{Carry in} das Vorzeichenbit \(\neq\) \emph{Carry out} des Vorzeichenbits.
\end{itemize}

\paragraph{Vorzeichenverl√§ngerung (Sign Extension).}
Erweitere eine Zweierkomplementzahl auf mehr Bit, indem du die \emph{linke f√ºhrende Ziffer} wiederholst:
\begin{itemize}
	\item positiv: \(\texttt{0}\)en voran (z.\,B. \(\texttt{0010}\ \to\ \texttt{0000 0010}\))
	\item negativ: \(\texttt{1}\)en voran (z.\,B. \(\texttt{1110}\ \to\ \texttt{1111 1110}\))
\end{itemize}

\subsection*{Vergleich zu anderen Darstellungen}
\begin{description}
	\item[Vorzeichen \& Betrag:] Einfach zu verstehen (ein Bit f√ºrs Vorzeichen), aber zwei Nullen (\(+0\) und \(-0\)) und Subtraktion ist umst√§ndlich.
	\item[Einerkomplement:] Auch zwei Nullen und kompliziertere Addition (End-Around-Carry).
	\item[Zweierkomplement:] \textbf{Standard in nahezu allen modernen CPUs} ‚Äì schnell, eindeutig, hardwarefreundlich.
\end{description}

\subsection*{Beispiele (4-Bit)}
\begin{center}
	\begin{tabular}{c|r@{\qquad}c|r}
		\textbf{Bitmuster} & \textbf{Dezimal} & \textbf{Bitmuster} & \textbf{Dezimal} \\
		\hline
		\texttt{0111} & $+7$ & \texttt{1001} & $-7$ \\
		\texttt{0101} & $+5$ & \texttt{1011} & $-5$ \\
		\texttt{0000} & $0$  & \texttt{1111} & $-1$ \\
		\texttt{1000} & $-8$ & \texttt{1101} & $-3$ \\
	\end{tabular}
\end{center}


\subsection*{Abbildung}
\begin{figure}[H]
	\centering
	\includegraphics[width=.72\textwidth]{4Bit-2Komplement.png}
	\caption{4-Bit-Zweierkomplement: Zuordnung der Bitmuster zu Dezimalwerten und Bildung der negativen Werte (\(+1\) nach Bitinvertierung).}
	\label{fig:zweierkomplement-4bit}
\end{figure}

% Optional: kurze √úbung (kannst du bei Bedarf aktivieren)
% \paragraph{√úbung.}
% Wandle \(345_{10}\) in Bin√§r, Oktal und Hex um.
% Pr√ºfe: \(100_{10} = 84_{12}\) (Begr√ºndung).





\chapter{[Thema 1]}
\section{Grundlagen}
Hier beginnen wir mit deinem ersten Thema.

\chapter{[Thema 2]}
...

\backmatter
\chapter*{Anhang}
Quellen, Glossar, etc.

\end{document}

