% !TeX program = lualatex
\documentclass[../skript/main.tex]{subfiles}
\begin{document}
	
\chapter{Einf√ºhrung}\label{chap:einfuehrung}
\section{Der Begriff Informatik}

Das Wort \textbf{Informatik} setzt sich aus zwei Teilen zusammen: \emph{Information} und \emph{Automatik}. 
Urspr√ºnglich wurde der Begriff in den 1950er Jahren in Frankreich gepr√§gt 
(\glqq informatique\grqq{}) und fand sp√§ter auch im deutschsprachigen Raum Verbreitung. 
In anderen Sprachen wird der Bereich meist \glqq Computer Science\grqq{} genannt, 
was die technische Seite st√§rker betont. 

\subsection{Information}
Der erste Bestandteil, \emph{Information}, bezieht sich auf Daten, die eine Bedeutung tragen. 
Information ist also nicht einfach nur eine Ansammlung von Zeichen oder Zahlen, 
sondern sie entsteht erst durch die \emph{Interpretation} von Daten in einem bestimmten Kontext.  
Beispielsweise ist die Zahl \glqq 42\grqq{} zun√§chst nur ein einzelner Wert.
Wird sie jedoch im Zusammenhang mit einer Temperaturangabe, einem Alter oder einem Ergebnis verstanden, wird daraus eine Information.  
Die Informatik besch√§ftigt sich also damit, Informationen \emph{darzustellen}, 
\emph{zu speichern}, \emph{zu √ºbertragen} und \emph{zu verarbeiten}.

\subsection{Automatik}
Der zweite Bestandteil, \emph{Matik} (von Automatik), bedeutet, dass diese Informationsverarbeitung 
durch Maschinen ‚Äì insbesondere Computer ‚Äì automatisiert geschieht.  
Ein zentrales Ziel der Informatik ist es, Verfahren zu entwickeln, die es erm√∂glichen, 
Informationen mithilfe von Computern effizient und zuverl√§ssig zu verarbeiten. 
Dazu geh√∂ren das Erstellen von Programmen, das Entwerfen von Algorithmen 
sowie die Entwicklung von Systemen, die Informationen ohne manuelle Eingriffe verarbeiten k√∂nnen.

\section{Bedeutung der Informatik}
Die Informatik kann somit als \emph{Wissenschaft von der systematischen Verarbeitung von Informationen, insbesondere mit Hilfe von Computern}, verstanden werden. 
Sie ist nicht nur eine technische Disziplin, sondern verbindet Elemente aus 
Mathematik, Ingenieurwissenschaften, Logik und zunehmend auch Sozial- und Geisteswissenschaften. 
Heute pr√§gt die Informatik nahezu alle Bereiche des t√§glichen Lebens: 
von Smartphones und dem Internet √ºber moderne Autos bis hin zu Medizin, Wirtschaft und Wissenschaft.

\section{Was tun eigentlich Computer?}

Computer \emph{verarbeiten Daten}. Sie f√ºhren Berechnungen aus, speichern, √ºbertragen und strukturieren Daten ‚Äî aber sie ‚Äûverstehen‚Äú keine Bedeutung im menschlichen Sinn. Bedeutung (Information) entsteht erst beim Menschen (oder in einem Modell), wenn Daten in \emph{Kontext} gesetzt werden. Der Kernprozess ist daher zweistufig:

\begin{enumerate}
	\item \textbf{Repr√§sentation:} Aus \emph{Information} werden \emph{Daten}, indem wir festlegen, wie etwas als Zeichen/Zahlen (Bits) dargestellt wird.
	\item \textbf{Abstraktion:} Aus \emph{Daten} wird (wieder) \emph{Information}, indem wir Details weglassen, strukturieren und die Daten in einem Modell deuten.
\end{enumerate}

\subsection{Von Information zu Daten: Repr√§sentation}

\emph{Repr√§sentation} bedeutet: Wir legen eine \textbf{Abbildung} fest, die etwas Bedeutungsvolles (Information) in ein \textbf{Datenformat} √ºberf√ºhrt, das der Computer verarbeiten kann.
Formal kann man das als Funktion auffassen:
\[
\mathrm{rep}:\ \text{Information} \times \text{Kontext} \;\to\; \text{Daten (Bits)}.
\]


\subsection{Von Daten zu Information: Abstraktion}

\emph{Abstraktion} bedeutet: Wir \textbf{interpretieren} Daten in einem passenden Modell und \textbf{lassen Details weg}, die f√ºr die Fragestellung nicht n√∂tig sind. So entsteht Bedeutung.
Formal:
\[
\mathrm{abs}:\ \text{Daten (Bits)} \times \text{Modell/Kontext} \;\to\; \text{Information}.
\]

\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\textwidth]{info-daten.png}% ggf. Pfad anpassen
	\caption{Wechselspiel zwischen Repr√§sentation (Information ‚Üí Daten) und Abstraktion (Daten ‚Üí Information).}
	\label{fig:info-daten}
\end{figure}

\section{Bits und Bytes}

Ein \textbf{Bit} (binary digit) ist die kleinste Informationseinheit im Rechner: Es kann genau zwei Zust√§nde annehmen, meist als \texttt{0} und \texttt{1} notiert. Physikalisch werden Bits z.\,B. durch zwei Spannungsniveaus, magnetische Ausrichtungen oder Lichtimpulse realisiert.

Einzelne Bits sind f√ºr die Verarbeitung jedoch zu fein. Deshalb werden Bits zu \textbf{Gruppen} zusammengefasst und \emph{gruppenweise} gelesen/geschrieben:

\begin{itemize}
	\item \textbf{Byte} = 8 Bit (heute die gebr√§uchlichste Grundeinheit; in den meisten Architekturen zugleich die \emph{kleinste adressierbare Einheit}).
	\item \textbf{Nibble} = 4 Bit (halbes Byte; n√ºtzlich z.\,B. bei Hexadezimaldarstellungen).
	\item \textbf{Wort (Word)} = \emph{architekturabh√§ngige} Arbeitsbreite der CPU (typisch 16, 32 oder 64 Bit).
	\item \textbf{Doppelwort/Quadwort} = Vielfache der Wortbreite (z.\,B. 32/64/128 Bit).
\end{itemize}

\subsection{Wer bestimmt die Lesegruppen?}
\textbf{Hardware:} Die \emph{Register- und ALU-Breite} eines Prozessors legt fest, wie viele Bits er in einem Schritt besonders effizient verarbeiten kann (z.\,B. 32-Bit oder 64-Bit). Auch \emph{Datenbus} und \emph{Cache-Zeilengr√∂√üen} beg√ºnstigen das Holen/Speichern ganzer Bytes-, Wort- oder Mehrfach-Wort-Bl√∂cke. Moderne CPUs k√∂nnen zus√§tzlich mit Vektor\-/SIMD-Einheiten noch gr√∂√üere Pakete (z.\,B. 128/256/512 Bit) auf einmal verarbeiten.

\textbf{Software/Betriebssystem:} Damit die Hardwarebreite genutzt werden kann, muss das \emph{Betriebssystem} die Architektur unterst√ºtzen (32-Bit- oder 64-Bit-Modus, Treiber, Systembibliotheken, ABI). Ein 64-Bit-Prozessor entfaltet seine Vorteile erst vollst√§ndig mit einem 64-Bit-Betriebssystem und passenden Programmen; andernfalls arbeitet er im 32-Bit-Kompatibilit√§tsmodus.

\paragraph{Beispiele.}
\begin{itemize}
	\item \textbf{32-Bit-System:} Die CPU arbeitet effizient mit 32-Bit-W√∂rtern (z.\,B. \texttt{int32}); Zeiger/Adressen sind 32 Bit breit. Daten werden h√§ufig in 32-Bit-Schritten geladen/geschrieben, obwohl der Speicher byteweise adressiert wird.
	\item \textbf{64-Bit-System:} Register und Zeiger sind 64 Bit breit. Das System kann gr√∂√üere Zahlenbereiche adressieren und pro Schritt breitere Daten verarbeiten; trotzdem bleiben Bytes (8 Bit) die kleinste adressierbare Einheit.
\end{itemize}
\newpage
\section{Gr√∂√üe der Daten}

\begin{center}
	\begin{tabular}{r c l c l l}
		$1~\text{k}$ & = & $1024~\text{Bit}$ & = & $2^{10}$  & (k = Kilo)\\
		$1~\text{M}$ & = & $1024 \times 1024~\text{Bit}$ & = & $2^{20}$  & (M = Mega)\\
		$1~\text{G}$ & = & $1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{30}$  & (G = Giga)\\
		$1~\text{T}$ & = & $1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{40}$  & (T = Tera)\\
		$1~\text{P}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{50}$  & (P = Peta)\\
		$1~\text{E}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{60}$  & (E = Exa)\\
		$1~\text{Z}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{70}$  & (Z = Zetta)\\
		$1~\text{Y}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{80}$  & (Y = Yotta)\\
	\end{tabular}
\end{center}

\section{Textdarstellung}

\paragraph{Von ASCII zu Unicode ‚Äî warum √ºberhaupt?}
Fr√ºhe Computersysteme nutzten \textbf{ASCII} (American Standard Code for Information Interchange, 1960er Jahre). ASCII ist ein 7-Bit-Zeichensatz mit 128 Zeichen: lateinische Grundbuchstaben A‚ÄìZ/a‚Äìz, Ziffern, Satzzeichen und Steuerzeichen (z.\,B. Zeilenumbruch). F√ºr englischen Text gen√ºgte das, \emph{aber}:
Umlaute (√§, √∂, √º), Akzente (√©), das Euro-Zeichen (‚Ç¨), kyrillisch (–ñ), griechisch (Œ©), arabisch ({\arabicfont ŸÖ}), asiatische Schriften ({\cjkfont Êó•}), Emojis ({\emojifont üòä}) \emph{fehlten}.
‚Äû√©‚Äú (NFC) vs. ‚Äûe\combacute‚Äú (NFD) bzw. ‚Äûe + \dottedcircle\combacute‚Äú.
\emph{fehlten}.


Als √úbergang entstanden viele \textbf{‚Äûerweiterte ASCII‚Äú-Codepages} (8-Bit, 256 Zeichen), z.\,B. \texttt{ISO-8859-1}, \texttt{Windows-1252}, \texttt{KOI8-R}. Jede deckte \emph{einen} Sprachraum ab. Ergebnis: Inkompatibilit√§ten (sogenanntes \emph{Mojibake}), weil dieselben Bytewerte je nach Codepage andere Zeichen bedeuten.

\textbf{Unicode} (seit 1991) l√∂st dieses Grundproblem: \emph{ein} weltweiter Zeichensatz f√ºr \emph{alle} Schriftsysteme, Symbole, technische Zeichen und Emojis. Ziel: \emph{‚ÄûJedem Zeichen ein eindeutiger Codepunkt‚Äú} ‚Äî unabh√§ngig von Sprache, Plattform oder Anwendung.

\paragraph{Begriffe sauber trennen}
\begin{itemize}
	\item \textbf{Codepunkt} (Unicode): eine Nummer in der Form \texttt{U+XXXX} (z.\,B. \texttt{U+00E4} = ‚Äû√§‚Äú, \texttt{U+20AC} = ‚Äû‚Ç¨‚Äú, \texttt{U+1F60A} = ‚Äûüòä‚Äú).
	\item \textbf{Kodierung} (Encoding): konkrete Regel, wie Codepunkte in \emph{Bytes} umgesetzt werden (z.\,B. UTF-8, UTF-16, UTF-32).
	\item \textbf{Graphem-Cluster}: was der Mensch als ‚Äûein Zeichen‚Äú wahrnimmt (z.\,B. ‚Äûe‚Äú + kombinierender Akzent \texttt{U+0301} $\to$ ‚Äû√©‚Äú, oder Familien-Emoji aus mehreren Codepunkten).
\end{itemize}

\paragraph{Wichtige Unicode-Kodierungen}
\begin{itemize}
	\item \textbf{UTF-8} (variabel, 1‚Äì4 Byte pro Codepunkt): ASCII-Zeichen bleiben 1 Byte (abw√§rtskompatibel), alle anderen werden als 2‚Äì4 Byte kodiert. Heutzutage Standard im Web, in Dateien und Schnittstellen.
	\item \textbf{UTF-16} (variabel, 2 oder 4 Byte): Basis-Mehrsprachige Ebene (BMP) meist 2 Byte; Supplement√§rzeichen (z.\,B. viele Emojis) als Surrogatpaare (4 Byte). Achtung auf Byte-Reihenfolge (\emph{Endianness}) und optionales \emph{BOM}.
	\item \textbf{UTF-32} (fix 4 Byte): einfacher, aber speicherintensiv; praktisch v.\,a. intern in manchen Systemen.
\end{itemize}

\paragraph{Historische Entwicklung in K√ºrze}
\begin{description}
	\item[1963] ASCII (7-Bit) standardisiert Grundzeichen und Steuerzeichen.
	\item[1980er] Viele 8-Bit-Codepages (\texttt{ISO-8859-x}, \texttt{Windows-125x}) ‚Äî regionale L√∂sungen, wenig kompatibel.
	\item[1991+] Unicode-Projekt: \emph{ein} universeller Zeichensatz; Trennung von \emph{Zeichen} (Codepunkte) und \emph{Kodierung} (UTFs).
	\item[2000er+] UTF-8 setzt sich global durch (Internet, Linux/Unix, moderne Apps und Protokolle).
\end{description}

\paragraph{Wie wird Unicode praktisch genutzt?}
\begin{itemize}
	\item \textbf{Dateien und Protokolle:} Textdateien, JSON, HTML, E-Mails, Datenbanken ‚Äî fast √ºberall ist UTF-8 √ºblich. Wichtig: \emph{Encoding angeben} (z.\,B. HTTP \texttt{Content-Type}, HTML \texttt{<meta charset="utf-8">}, DB-Kollation).
	\item \textbf{Betriebssysteme:} Dateinamen und Konsolen sind (je nach System) Unicode-f√§hig; moderne Terminals verstehen UTF-8.
	\item \textbf{Programmiersprachen:} Python, Java, JavaScript, C\# u.\,a. arbeiten intern mit Unicode-Zeichenketten; I/O nutzt meist UTF-8.
\end{itemize}

%\chapter{Einf√ºhrung}
%Dieses Skript dient als Einf√ºhrung in zentrale Konzepte der Informatik.
%Wir verwenden das \texttt{subfiles}-Paket, um Kapitel \emph{modular} zu pflegen.
%\begin{itemize}
%  \item Kompiliere \texttt{main.tex} f√ºr das Gesamtwerk.
%  \item Oder kompiliere \texttt{chapters/einfuehrung.tex} direkt, wenn du nur dieses Kapitel testen m√∂chtest.
%\end{itemize}
%
%\section{Organisation des Projekts}
%Die Verzeichnisstruktur ist wie folgt angelegt:
%\begin{verbatim}
%latex-book-subfiles/
%‚îú‚îÄ‚îÄ main.tex
%‚îú‚îÄ‚îÄ chapters/
%‚îÇ   ‚îú‚îÄ‚îÄ einfuehrung.tex
%‚îÇ   ‚îî‚îÄ‚îÄ zweierkomplement.tex
%‚îú‚îÄ‚îÄ appendix/
%‚îÇ   ‚îî‚îÄ‚îÄ anhang.tex
%‚îî‚îÄ‚îÄ figures/
%\end{verbatim}
%
%\section{Bilder und Pfade}
%F√ºr den Hauptlauf ist \verb|\graphicspath{{figures/}}| gesetzt.
%In Subfiles kann mit \verb|\graphicspath{{\subfix{../figures/}}}| gearbeitet werden,
%damit Einzell√§ufe ebenfalls funktionieren.

\end{document}
