% !TeX program = lualatex
\documentclass[../skript/main.tex]{subfiles}
\begin{document}
	
\chapter{EinfÃ¼hrung}\label{chap:einfuehrung}
\section{Der Begriff Informatik}

Das Wort \textbf{Informatik} setzt sich aus zwei Teilen zusammen: \emph{Information} und \emph{Automatik}. 
UrsprÃ¼nglich wurde der Begriff in den 1950er Jahren in Frankreich geprÃ¤gt 
(\glqq informatique\grqq{}) und fand spÃ¤ter auch im deutschsprachigen Raum Verbreitung. 
In anderen Sprachen wird der Bereich meist \glqq Computer Science\grqq{} genannt, 
was die technische Seite stÃ¤rker betont. 

\subsection{Information}
Der erste Bestandteil, \emph{Information}, bezieht sich auf Daten, die eine Bedeutung tragen. 
Information ist also nicht einfach nur eine Ansammlung von Zeichen oder Zahlen, 
sondern sie entsteht erst durch die \emph{Interpretation} von Daten in einem bestimmten Kontext.  
Beispielsweise ist die Zahl \glqq 42\grqq{} zunÃ¤chst nur ein einzelner Wert.
Wird sie jedoch im Zusammenhang mit einer Temperaturangabe, einem Alter oder einem Ergebnis verstanden, wird daraus eine Information.  
Die Informatik beschÃ¤ftigt sich also damit, Informationen \emph{darzustellen}, 
\emph{zu speichern}, \emph{zu Ã¼bertragen} und \emph{zu verarbeiten}.

\subsection{Automatik}
Der zweite Bestandteil, \emph{Matik} (von Automatik), bedeutet, dass diese Informationsverarbeitung 
durch Maschinen â€“ insbesondere Computer â€“ automatisiert geschieht.  
Ein zentrales Ziel der Informatik ist es, Verfahren zu entwickeln, die es ermÃ¶glichen, 
Informationen mithilfe von Computern effizient und zuverlÃ¤ssig zu verarbeiten. 
Dazu gehÃ¶ren das Erstellen von Programmen, das Entwerfen von Algorithmen 
sowie die Entwicklung von Systemen, die Informationen ohne manuelle Eingriffe verarbeiten kÃ¶nnen.

\section{Bedeutung der Informatik}
Die Informatik kann somit als \emph{Wissenschaft von der systematischen Verarbeitung von Informationen, insbesondere mit Hilfe von Computern}, verstanden werden. 
Sie ist nicht nur eine technische Disziplin, sondern verbindet Elemente aus 
Mathematik, Ingenieurwissenschaften, Logik und zunehmend auch Sozial- und Geisteswissenschaften. 
Heute prÃ¤gt die Informatik nahezu alle Bereiche des tÃ¤glichen Lebens: 
von Smartphones und dem Internet Ã¼ber moderne Autos bis hin zu Medizin, Wirtschaft und Wissenschaft.

\section{Was tun eigentlich Computer?}

Computer \emph{verarbeiten Daten}. Sie fÃ¼hren Berechnungen aus, speichern, Ã¼bertragen und strukturieren Daten â€” aber sie â€žverstehenâ€œ keine Bedeutung im menschlichen Sinn. Bedeutung (Information) entsteht erst beim Menschen (oder in einem Modell), wenn Daten in \emph{Kontext} gesetzt werden. Der Kernprozess ist daher zweistufig:

\begin{enumerate}
	\item \textbf{ReprÃ¤sentation:} Aus \emph{Information} werden \emph{Daten}, indem wir festlegen, wie etwas als Zeichen/Zahlen (Bits) dargestellt wird.
	\item \textbf{Abstraktion:} Aus \emph{Daten} wird (wieder) \emph{Information}, indem wir Details weglassen, strukturieren und die Daten in einem Modell deuten.
\end{enumerate}

\subsection{Von Information zu Daten: ReprÃ¤sentation}

\emph{ReprÃ¤sentation} bedeutet: Wir legen eine \textbf{Abbildung} fest, die etwas Bedeutungsvolles (Information) in ein \textbf{Datenformat} Ã¼berfÃ¼hrt, das der Computer verarbeiten kann.
Formal kann man das als Funktion auffassen:
\[
\mathrm{rep}:\ \text{Information} \times \text{Kontext} \;\to\; \text{Daten (Bits)}.
\]


\subsection{Von Daten zu Information: Abstraktion}

\emph{Abstraktion} bedeutet: Wir \textbf{interpretieren} Daten in einem passenden Modell und \textbf{lassen Details weg}, die fÃ¼r die Fragestellung nicht nÃ¶tig sind. So entsteht Bedeutung.
Formal:
\[
\mathrm{abs}:\ \text{Daten (Bits)} \times \text{Modell/Kontext} \;\to\; \text{Information}.
\]

\begin{figure}[H]
	\centering
	\includegraphics[width=0.55\textwidth]{info-daten.png}% ggf. Pfad anpassen
	\caption{Wechselspiel zwischen ReprÃ¤sentation (Information â†’ Daten) und Abstraktion (Daten â†’ Information).}
	\label{fig:info-daten}
\end{figure}

\section{Bits und Bytes}

Ein \textbf{Bit} (binary digit) ist die kleinste Informationseinheit im Rechner: Es kann genau zwei ZustÃ¤nde annehmen, meist als \texttt{0} und \texttt{1} notiert. Physikalisch werden Bits z.\,B. durch zwei Spannungsniveaus, magnetische Ausrichtungen oder Lichtimpulse realisiert.

Einzelne Bits sind fÃ¼r die Verarbeitung jedoch zu fein. Deshalb werden Bits zu \textbf{Gruppen} zusammengefasst und \emph{gruppenweise} gelesen/geschrieben:

\begin{itemize}
	\item \textbf{Byte} = 8 Bit (heute die gebrÃ¤uchlichste Grundeinheit; in den meisten Architekturen zugleich die \emph{kleinste adressierbare Einheit}).
	\item \textbf{Nibble} = 4 Bit (halbes Byte; nÃ¼tzlich z.\,B. bei Hexadezimaldarstellungen).
	\item \textbf{Wort (Word)} = \emph{architekturabhÃ¤ngige} Arbeitsbreite der CPU (typisch 16, 32 oder 64 Bit).
	\item \textbf{Doppelwort/Quadwort} = Vielfache der Wortbreite (z.\,B. 32/64/128 Bit).
\end{itemize}

\subsection{Wer bestimmt die Lesegruppen?}
\textbf{Hardware:} Die \emph{Register- und ALU-Breite} eines Prozessors legt fest, wie viele Bits er in einem Schritt besonders effizient verarbeiten kann (z.\,B. 32-Bit oder 64-Bit). Auch \emph{Datenbus} und \emph{Cache-ZeilengrÃ¶ÃŸen} begÃ¼nstigen das Holen/Speichern ganzer Bytes-, Wort- oder Mehrfach-Wort-BlÃ¶cke. Moderne CPUs kÃ¶nnen zusÃ¤tzlich mit Vektor\-/SIMD-Einheiten noch grÃ¶ÃŸere Pakete (z.\,B. 128/256/512 Bit) auf einmal verarbeiten.

\textbf{Software/Betriebssystem:} Damit die Hardwarebreite genutzt werden kann, muss das \emph{Betriebssystem} die Architektur unterstÃ¼tzen (32-Bit- oder 64-Bit-Modus, Treiber, Systembibliotheken, ABI). Ein 64-Bit-Prozessor entfaltet seine Vorteile erst vollstÃ¤ndig mit einem 64-Bit-Betriebssystem und passenden Programmen; andernfalls arbeitet er im 32-Bit-KompatibilitÃ¤tsmodus.

\paragraph{Beispiele.}
\begin{itemize}
	\item \textbf{32-Bit-System:} Die CPU arbeitet effizient mit 32-Bit-WÃ¶rtern (z.\,B. \texttt{int32}); Zeiger/Adressen sind 32 Bit breit. Daten werden hÃ¤ufig in 32-Bit-Schritten geladen/geschrieben, obwohl der Speicher byteweise adressiert wird.
	\item \textbf{64-Bit-System:} Register und Zeiger sind 64 Bit breit. Das System kann grÃ¶ÃŸere Zahlenbereiche adressieren und pro Schritt breitere Daten verarbeiten; trotzdem bleiben Bytes (8 Bit) die kleinste adressierbare Einheit.
\end{itemize}
\newpage
\section{GrÃ¶ÃŸe der Daten}

\begin{center}
	\begin{tabular}{r c l c l l}
		$1~\text{k}$ & = & $1024~\text{Bit}$ & = & $2^{10}$  & (k = Kilo)\\
		$1~\text{M}$ & = & $1024 \times 1024~\text{Bit}$ & = & $2^{20}$  & (M = Mega)\\
		$1~\text{G}$ & = & $1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{30}$  & (G = Giga)\\
		$1~\text{T}$ & = & $1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{40}$  & (T = Tera)\\
		$1~\text{P}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{50}$  & (P = Peta)\\
		$1~\text{E}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{60}$  & (E = Exa)\\
		$1~\text{Z}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{70}$  & (Z = Zetta)\\
		$1~\text{Y}$ & = & $1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024 \times 1024~\text{Bit}$ & = & $2^{80}$  & (Y = Yotta)\\
	\end{tabular}
\end{center}

\section{Textdarstellung}

\paragraph{Von ASCII zu Unicode â€” warum Ã¼berhaupt?}
FrÃ¼he Computersysteme nutzten \textbf{ASCII} (American Standard Code for Information Interchange, 1960er Jahre). ASCII ist ein 7-Bit-Zeichensatz mit 128 Zeichen: lateinische Grundbuchstaben Aâ€“Z/aâ€“z, Ziffern, Satzzeichen und Steuerzeichen (z.\,B. Zeilenumbruch). FÃ¼r englischen Text genÃ¼gte das, \emph{aber}:
Umlaute (Ã¤, Ã¶, Ã¼), Akzente (Ã©), das Euro-Zeichen (â‚¬), kyrillisch (Ð–), griechisch (Î©), arabisch ({\arabicfont Ù…}), asiatische Schriften ({\cjkfont æ—¥}), Emojis ({\emojifont ðŸ˜Š}) \emph{fehlten}.
â€žÃ©â€œ (NFC) vs. â€že\combacuteâ€œ (NFD) bzw. â€že + \dottedcircle\combacuteâ€œ.
\emph{fehlten}.


Als Ãœbergang entstanden viele \textbf{â€žerweiterte ASCIIâ€œ-Codepages} (8-Bit, 256 Zeichen), z.\,B. \texttt{ISO-8859-1}, \texttt{Windows-1252}, \texttt{KOI8-R}. Jede deckte \emph{einen} Sprachraum ab. Ergebnis: InkompatibilitÃ¤ten (sogenanntes \emph{Mojibake}), weil dieselben Bytewerte je nach Codepage andere Zeichen bedeuten.

\textbf{Unicode} (seit 1991) lÃ¶st dieses Grundproblem: \emph{ein} weltweiter Zeichensatz fÃ¼r \emph{alle} Schriftsysteme, Symbole, technische Zeichen und Emojis. Ziel: \emph{â€žJedem Zeichen ein eindeutiger Codepunktâ€œ} â€” unabhÃ¤ngig von Sprache, Plattform oder Anwendung.

\paragraph{Begriffe sauber trennen}
\begin{itemize}
	\item \textbf{Codepunkt} (Unicode): eine Nummer in der Form \texttt{U+XXXX} (z.\,B. \texttt{U+00E4} = â€žÃ¤â€œ, \texttt{U+20AC} = â€žâ‚¬â€œ, \texttt{U+1F60A} = â€žðŸ˜Šâ€œ).
	\item \textbf{Kodierung} (Encoding): konkrete Regel, wie Codepunkte in \emph{Bytes} umgesetzt werden (z.\,B. UTF-8, UTF-16, UTF-32).
	\item \textbf{Graphem-Cluster}: was der Mensch als â€žein Zeichenâ€œ wahrnimmt (z.\,B. â€žeâ€œ + kombinierender Akzent \texttt{U+0301} $\to$ â€žÃ©â€œ, oder Familien-Emoji aus mehreren Codepunkten).
\end{itemize}

\paragraph{Wichtige Unicode-Kodierungen}
\begin{itemize}
	\item \textbf{UTF-8} (variabel, 1â€“4 Byte pro Codepunkt): ASCII-Zeichen bleiben 1 Byte (abwÃ¤rtskompatibel), alle anderen werden als 2â€“4 Byte kodiert. Heutzutage Standard im Web, in Dateien und Schnittstellen.
	\item \textbf{UTF-16} (variabel, 2 oder 4 Byte): Basis-Mehrsprachige Ebene (BMP) meist 2 Byte; SupplementÃ¤rzeichen (z.\,B. viele Emojis) als Surrogatpaare (4 Byte). Achtung auf Byte-Reihenfolge (\emph{Endianness}) und optionales \emph{BOM}.
	\item \textbf{UTF-32} (fix 4 Byte): einfacher, aber speicherintensiv; praktisch v.\,a. intern in manchen Systemen.
\end{itemize}

\paragraph{Historische Entwicklung in KÃ¼rze}
\begin{description}
	\item[1963] ASCII (7-Bit) standardisiert Grundzeichen und Steuerzeichen.
	\item[1980er] Viele 8-Bit-Codepages (\texttt{ISO-8859-x}, \texttt{Windows-125x}) â€” regionale LÃ¶sungen, wenig kompatibel.
	\item[1991+] Unicode-Projekt: \emph{ein} universeller Zeichensatz; Trennung von \emph{Zeichen} (Codepunkte) und \emph{Kodierung} (UTFs).
	\item[2000er+] UTF-8 setzt sich global durch (Internet, Linux/Unix, moderne Apps und Protokolle).
\end{description}

\paragraph{Wie wird Unicode praktisch genutzt?}
\begin{itemize}
	\item \textbf{Dateien und Protokolle:} Textdateien, JSON, HTML, E-Mails, Datenbanken â€” fast Ã¼berall ist UTF-8 Ã¼blich. Wichtig: \emph{Encoding angeben} (z.\,B. HTTP \texttt{Content-Type}, HTML \texttt{<meta charset="utf-8">}, DB-Kollation).
	\item \textbf{Betriebssysteme:} Dateinamen und Konsolen sind (je nach System) Unicode-fÃ¤hig; moderne Terminals verstehen UTF-8.
	\item \textbf{Programmiersprachen:} Python, Java, JavaScript, C\# u.\,a. arbeiten intern mit Unicode-Zeichenketten; I/O nutzt meist UTF-8.
\end{itemize}

%\chapter{EinfÃ¼hrung}
%Dieses Skript dient als EinfÃ¼hrung in zentrale Konzepte der Informatik.
%Wir verwenden das \texttt{subfiles}-Paket, um Kapitel \emph{modular} zu pflegen.
%\begin{itemize}
%  \item Kompiliere \texttt{main.tex} fÃ¼r das Gesamtwerk.
%  \item Oder kompiliere \texttt{chapters/einfuehrung.tex} direkt, wenn du nur dieses Kapitel testen mÃ¶chtest.
%\end{itemize}
%
%\section{Organisation des Projekts}
%Die Verzeichnisstruktur ist wie folgt angelegt:
%\begin{verbatim}
%latex-book-subfiles/
%â”œâ”€â”€ main.tex
%â”œâ”€â”€ chapters/
%â”‚   â”œâ”€â”€ einfuehrung.tex
%â”‚   â””â”€â”€ zweierkomplement.tex
%â”œâ”€â”€ appendix/
%â”‚   â””â”€â”€ anhang.tex
%â””â”€â”€ figures/
%\end{verbatim}
%
%\section{Bilder und Pfade}
%FÃ¼r den Hauptlauf ist \verb|\graphicspath{{figures/}}| gesetzt.
%In Subfiles kann mit \verb|\graphicspath{{\subfix{../figures/}}}| gearbeitet werden,
%damit EinzellÃ¤ufe ebenfalls funktionieren.

\end{document}
