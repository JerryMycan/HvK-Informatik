\documentclass[a4paper,12pt]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{enumitem}

\begin{document}
	
	\title{Prüfungsfragen über Formale Sprachen und Grammatiken}
	\author{Informatik - Jarek Mycan}
	\date{\today}
	\maketitle
	
	\section*{Antworten zu den Fragen über Sprachen und Grammatiken}
	
	\subsection*{1. Definitionen und Grundlagen}
	\begin{enumerate}
		\item Eine \textbf{formale Sprache} ist eine Menge von Wörtern über einem bestimmten Alphabet, die nach festen Regeln definiert sind.
		
		\item Eine \textbf{Grammatik} ist eine formale Beschreibung einer Sprache und besteht aus:
		\begin{itemize}
			\item einer Menge von \textbf{Nichtterminalen} (Variablen),
			\item einer Menge von \textbf{Terminalen} (Symbolen des Alphabets),
			\item einer Menge von \textbf{Produktionsregeln}, die beschreiben, wie Nichtterminale ersetzt werden können,
			\item einem \textbf{Startsymbol}, von dem die Ableitung beginnt.
		\end{itemize}
		
		\item \textbf{Terminale} sind die Symbole der Sprache, während \textbf{Nichtterminale} als Platzhalter für andere Zeichen oder Sequenzen dienen.
		
		\item Eine \textbf{reguläre Grammatik} definiert reguläre Sprachen und kann durch endliche Automaten erkannt werden. Eine \textbf{kontextfreie Grammatik} erlaubt rekursive Definitionen und wird durch Kellerautomaten verarbeitet.
		
		\item Eine \textbf{kontextfreie Grammatik (CFG)} ist eine Grammatik, bei der alle Produktionsregeln die Form $A \rightarrow \alpha$ haben, wobei $A$ ein Nichtterminal und $\alpha$ eine beliebige Zeichenfolge aus Terminalen und/oder Nichtterminalen ist.
		
		\item \subsection*{Reguläre Grammatik}
		\textbf{Vorteile:}
		\begin{itemize}
			\item \textbf{Einfach zu verstehen und zu verarbeiten} – Reguläre Grammatiken können mit \textbf{endlichen Automaten} erkannt werden.
			\item \textbf{Effiziente Verarbeitung} – Sie benötigen wenig Speicher, da kein Stack nötig ist.
			\item \textbf{Einfache Umsetzung} – Häufig genutzt in Suchalgorithmen und Compilern für Mustererkennung.
		\end{itemize}
		
		\textbf{Nachteile:}
		\begin{itemize}
			\item \textbf{Begrenzte Ausdruckskraft} – Keine verschachtelten Strukturen möglich, z. B. keine Klammerausdrücke $((()))$.
			\item \textbf{Nicht für alle Sprachen geeignet} – Beispielsweise kann die Sprache $\{ a^n b^n \mid n \geq 1 \}$ nicht mit einer regulären Grammatik beschrieben werden.
		\end{itemize}
		
		\subsection*{Kontextfreie Grammatik (CFG)}
		\textbf{Vorteile:}
		\begin{itemize}
			\item \textbf{Mehr Ausdruckskraft} – Kann auch \textbf{verschachtelte Strukturen} darstellen, z. B. mathematische Ausdrücke $((a + b) * c)$.
			\item \textbf{Geeignet für Programmiersprachen} – Sprachen wie Python oder C werden mit CFGs definiert.
			\item \textbf{Erkennt rekursive Strukturen} – Sprachen wie $\{ a^n b^n \mid n \geq 1 \}$ lassen sich damit einfach beschreiben.
		\end{itemize}
		
		\textbf{Nachteile:}
		\begin{itemize}
			\item \textbf{Aufwendiger zu verarbeiten} – Erfordert \textbf{Kellerautomaten} mit Speicher, was aufwendiger ist als ein endlicher Automat.
			\item \textbf{Parsing ist schwieriger} – Das Erkennen von CFGs, z. B. in Compilern, ist komplizierter als bei regulären Grammatiken.
			\item \textbf{Nicht immer effizient} – Einige Parsing-Verfahren für CFGs haben eine hohe Rechenzeit.
		\end{itemize}
		
		\subsection*{Zusammenfassung}
		\begin{itemize}
			\item \textbf{Reguläre Grammatiken} – Einfach, schnell, aber begrenzt.
			\item \textbf{Kontextfreie Grammatiken} – Mächtiger, aber komplexer zu verarbeiten.
		\end{itemize}
		
		Für einfache Muster wie Telefonnummern oder Suchmuster reichen \textbf{reguläre Grammatiken}. Für komplexere Strukturen wie Programmiersprachen oder mathematische Ausdrücke braucht man \textbf{kontextfreie Grammatiken}.
				\item \section*{Sind alle Programmiersprachen kontextfrei?}
		
		Nein, \textbf{nicht alle Programmiersprachen sind kontextfrei}. Während viele Aspekte einer Programmiersprache mit einer \textbf{kontextfreien Grammatik (CFG)} beschrieben werden können, gibt es einige wichtige Eigenschaften, die \textbf{über kontextfreie Sprachen hinausgehen}.
		
		\subsection*{1. Was ist kontextfrei in Programmiersprachen?}
		Die meisten grundlegenden Strukturen einer Programmiersprache sind \textbf{kontextfrei} und können mit einer kontextfreien Grammatik beschrieben werden:
		
		\textbf{Typische kontextfreie Elemente:}
		\begin{itemize}
			\item Verschachtelte Blöcke (z. B. \texttt{if-else}, \texttt{while}, \texttt{{}...{}}-Blöcke)
			\item Rekursive Strukturen (z. B. verschachtelte Funktionsaufrufe)
			\item Ausdrucksverarbeitung (z. B. $E \rightarrow E + E \mid E * E \mid (E) \mid id$)
		\end{itemize}
		
		\textbf{Beispiel für eine CFG einer einfachen arithmetischen Sprache:}
		\begin{align*}
			E &\rightarrow E + E \mid E * E \mid (E) \mid id
		\end{align*}
		Diese Grammatik beschreibt mathematische Ausdrücke mit \texttt{+}, \texttt{*} und Klammern.
		
		\subsection*{2. Warum sind Programmiersprachen nicht rein kontextfrei?}
		Es gibt Regeln in Programmiersprachen, die sich nicht mit kontextfreien Grammatiken allein beschreiben lassen:
		
		\textbf{Nicht-kontextfreie Eigenschaften:}
		\begin{itemize}
			\item \textbf{Variablenbindung \& Gültigkeitsbereiche (Scope Rules)} – Eine Variable muss deklariert werden, bevor sie verwendet werden kann.
			\item \textbf{Typüberprüfung (Type Checking)} – In Sprachen wie Java oder C müssen die Typen von Variablen stimmen. Beispiel: \texttt{int x = "hello";} ist syntaktisch korrekt, aber semantisch falsch.
			\item \textbf{Schlüsselwort-Überprüfung} – Z. B. darf \texttt{return} nur innerhalb von Funktionen verwendet werden.
			\item \textbf{Indentation in Python} – Python nutzt Einrückungen zur Strukturierung (\texttt{if}, \texttt{while}, \texttt{def}), was nicht durch eine CFG allein überprüfbar ist.
		\end{itemize}
		
		\subsection*{3. Wie werden Programmiersprachen dann geparst?}
		Da CFGs nicht ausreichen, benutzen \textbf{moderne Parser Kombinationen aus Techniken}:
		\begin{itemize}
			\item \textbf{Kontextfreie Grammatik für die Syntaxanalyse (Parsing)} – Parser-Generatoren wie \texttt{YACC}, \texttt{ANTLR}, \texttt{Bison} nutzen CFGs.
			\item \textbf{Zusätzliche Constraints für die Semantik} – \textbf{Typprüfung} und \textbf{Scope-Checks} werden durch \textbf{semantische Analysen} ergänzt.
			\item \textbf{Zusätzliche Maschinen (z. B. Kellerautomaten + Speicher)} – Typüberprüfung oder Scoping-Regeln benötigen \textbf{Kontextinformationen}.
		\end{itemize}
		
		\subsection*{Fazit}
		\textbf{Programmiersprachen sind nicht rein kontextfrei}, da einige ihrer Eigenschaften über kontextfreie Grammatiken hinausgehen. Während die Syntax oft kontextfrei ist, erfordert die Semantik (z. B. Typprüfung, Scope-Regeln) \textbf{kontextsensitive oder sogar allgemeinere Techniken}.
		
		\textbf{Praktisch:}
		\begin{itemize}
			\item \textbf{CFGs reichen für den Syntaxbaum (AST) aus.}
			\item \textbf{Zusätzliche semantische Analysen sind nötig, um gültige Programme zu erkennen.}
		\end{itemize}
		
		\textbf{Daher: Programmiersprachen = mehr als nur kontextfreie Sprachen!}	
	
	\end{enumerate}
	






		
	
	\subsection*{2. Chomsky-Hierarchie}
	\begin{enumerate}
		\item Die \textbf{Chomsky-Hierarchie} unterteilt Sprachen in vier Klassen:
		\begin{itemize}
			\item \textbf{Typ 3} (Reguläre Sprachen) – können durch endliche Automaten erkannt werden.
			\item \textbf{Typ 2} (Kontextfreie Sprachen) – durch Kellerautomaten erkannt.
			\item \textbf{Typ 1} (Kontextsensitive Sprachen) – durch linear beschränkte Turingmaschinen erkannt.
			\item \textbf{Typ 0} (Rekursiv aufzählbare Sprachen) – können von einer Turingmaschine erkannt werden.
		\end{itemize}
		
		\item Eine kontextfreie Grammatik hat Produktionsregeln der Form $A \rightarrow \gamma$, während eine kontextsensitive Grammatik auch Regeln der Form $\alpha A \beta \rightarrow \alpha \gamma \beta$ erlaubt.
		
		\item Jede reguläre Sprache ist auch eine kontextfreie Sprache, aber nicht jede kontextfreie Sprache ist regulär. Zum Beispiel ist $L = \{a^n b^n \mid n \geq 1\}$ kontextfrei, aber nicht regulär.
	\end{enumerate}
	
	\subsection*{3. Ableitungsprozesse}
	\begin{enumerate}
		\item Ein Wort kann abgeleitet werden, indem man wiederholt Produktionsregeln anwendet, bis nur noch Terminale übrig bleiben.
		
		\item Eine \textbf{Linksableitung} ersetzt in jedem Schritt das am weitesten links stehende Nichtterminal, während eine \textbf{Rechtsableitung} das am weitesten rechts stehende Nichtterminal ersetzt.
		
		\item Ein \textbf{Ableitungsbaum} ist eine hierarchische Struktur, die den schrittweisen Aufbau eines Wortes gemäß einer Grammatik darstellt.
	\end{enumerate}
	
	\subsection*{4. Ambiguität von Grammatiken}
	\begin{enumerate}
		\item Eine Grammatik ist \textbf{mehrdeutig}, wenn es mindestens zwei verschiedene Ableitungsbäume für ein Wort gibt.
		
		\item Man prüft Mehrdeutigkeit, indem man überprüft, ob ein Wort durch verschiedene Ableitungsbäume dargestellt werden kann.
		
		\item Eine mehrdeutige Grammatik kann oft durch Umformung in eine eindeutige Grammatik überführt werden, indem man alternative Produktionsregeln nutzt oder Zusatzsymbole einführt.
	\end{enumerate}
	
	\subsection*{5. Grammatik-Design}
	\begin{enumerate}
		\item Eine Grammatik für $a^n b^n c^n$ könnte sein:
		\begin{align*}
			S &\rightarrow a S b c \mid abc
		\end{align*}
		
		\item Eine Grammatik für Palindrome könnte sein:
		\begin{align*}
			S &\rightarrow a S a \mid b S b \mid a \mid b \mid \epsilon
		\end{align*}
		
		\item Eine Grammatik für $(ab)^n$ wäre:
		\begin{align*}
			S &\rightarrow ab S \mid ab
		\end{align*}
	\end{enumerate}
	
	\subsection*{6. Automaten und Grammatiken}
	\begin{enumerate}
		\item Ein \textbf{endlicher Automat} akzeptiert genau die regulären Sprachen.
		
		\item Ein \textbf{Kellerautomat} akzeptiert genau die kontextfreien Sprachen.
		
		\item Eine kontextfreie Sprache kann durch einen nichtdeterministischen Kellerautomaten erkannt werden, aber nicht jede kontextfreie Sprache kann durch einen deterministischen Kellerautomaten verarbeitet werden.
	\end{enumerate}
	
	\subsection*{7. Entscheidbarkeit und Komplexität}
	\begin{enumerate}
		\item Das Problem, ob eine kontextfreie Grammatik ein bestimmtes Wort akzeptiert, ist entscheidbar.
		
		\item Manche Sprachen sind nicht entscheidbar, weil es keine Turingmaschine gibt, die für jede Eingabe in endlicher Zeit terminiert.
		
		\item Eine entscheidbare Sprache hat ein Verfahren, das garantiert terminiert, während eine semi-entscheidbare Sprache ein Verfahren hat, das nur für akzeptierte Wörter terminiert.
	\end{enumerate}
	
	\subsection*{8. Pumping Lemma}
	\begin{enumerate}
		\item Das Pumping-Lemma besagt, dass jedes Wort einer regulären Sprache in Teile zerlegt werden kann, sodass ein Teil beliebig oft wiederholt werden kann.
		
		\item Um zu zeigen, dass $L = \{ a^n b^n \}$ nicht regulär ist, nimmt man an, es wäre regulär, zeigt aber dann durch Widerspruch mit dem Pumping-Lemma, dass das nicht sein kann.
	\end{enumerate}
	
\end{document}
