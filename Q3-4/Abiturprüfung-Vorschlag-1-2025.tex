\documentclass[a4paper,12pt]{article}
\usepackage[ngerman]{babel}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{geometry}
\geometry{left=2.5cm, right=2.5cm, top=2.5cm, bottom=2.5cm}
\usepackage{fancyhdr}
\pagestyle{fancy}
\fancyhf{}
%\rhead{Mündliche Abiturprüfung Informatik}
\lhead{Thema: OOP, Algorithmen, Daten Banken, Formale Sprachen}
\cfoot{\thepage}

\begin{document}
	
	\title{\textbf{Mündlichen Abiturprüfung -- Informatik}}
	\author{\textbf{Thema: OOP, Algorithmen, Daten Banken, Formale Sprachen}}
	\date{\today}
	\maketitle
	
	\section*{Aufgabe 1: Analyse eines Algorithmus}
	
	Ein unbekannter Algorithmus zur Berechnung einer speziellen mathematischen Funktion von Zahlen wird bereitgestellt. Der Name der Klasse lautet \texttt{Algorithmus}.
	
	\subsection*{Gegebener Java-Code}
	
\begin{verbatim}
public class Algorithmus {
	
	public static int berechne(int b, int e) {
		if (e == 0) {
			return 1;
		}
		return b * berechne(b, e - 1);
	}
	
	public static void main(String[] args) {
		int b = 3;
		int e = 3;
		System.out.println("Ergebnis: " + berechne(b, e));
	}
}
\end{verbatim}
	
	\subsection*{Teilaufgaben}
	
	\begin{enumerate}
		\item Beschreiben Sie die Funktionsweise des Algorithmus. Welche mathematische Berechnung führt die Methode \texttt{berechne} der Klasse \texttt{Algorithmus} durch?
		
		\item Welche Art der Implementierung wurde gewählt und welche Vor- oder Nachteile ergeben sich daraus?
		
		\item Bestimmen Sie die Zeitkomplexität des Algorithmus.
		
		\item Vergleichen Sie die rekursive Lösung mit einer iterativen Variante hinsichtlich Aufwand, Verständlichkeit und praktischer Anwendung.
	\end{enumerate}
	
	
\section*{Aufgabe 2: Datenmodellierung und Normalisierung}

Im SchulPortal der Heinrich-von-Kleist-Schule werden Schüler- und Elterndaten in einer relationalen Datenbank gespeichert. Die ursprüngliche Tabellenstruktur sieht wie folgt aus:

\begin{table}[h]
	\centering
	\caption{Ursprüngliche nicht normalisierte Tabelle}
	\resizebox{\textwidth}{!}{
		\begin{tabular}{|c|c|c|c|c|c|c|c|c|}
			\hline
			SchuelerID & Vorname & Nachname & Adresse (Str., Stadt, PLZ) & Klasse & ElternID & Name\_Elternteil & Telefonnummer\_Eltern \\
			\hline
			1 & Anna & Müller & Hauptstr. 12, Berlin, 10115 & 10A & E101 & Peter Müller & 0301234567 \\
			2 & Lukas & Becker & Marktstr. 5, Hamburg, 20095 & 10B & E102 & Sabine Becker & 0407654321 \\
			3 & Anna & Müller & Hauptstr. 12, Berlin, 10115 & 10A & E102 & Sabine Becker & 0407654321 \\
			4 & Marie & Schmitt & Lindenallee 9, München, 80331 & 10C & E103 & Julia Schmitt & 0893344556 \\
			\hline
	\end{tabular}}
\end{table}

\subsection*{Teilaufgaben:}

\begin{enumerate}
	\item Identifizieren Sie Redundanzen und Anomalien in der Tabelle.
	
	\item Zerlegen Sie die nicht normalisierte Tabelle schrittweise und normalisieren Sie sie bis zur 3. Normalform. Geben Sie die neu entstandenen Tabellen jeweils an.
	
	\item Erläutern Sie, welche konkreten Vorteile die Normalisierung in diesem Fall für das SchulPortal bringt.
\end{enumerate}


\section*{Aufgabe 3: Analyse einer formalen Grammatik für deutsche Sätze}

Gegeben sei folgende formale Grammatik \( G \):

\begin{itemize}
	\item Nichtterminale: \( \{ \texttt{<satz>}, \texttt{<subjekt>}, \texttt{<prädikat>}, \texttt{<objekt>}, \texttt{<substantivgruppe>}, \texttt{<artikel>}, \texttt{<substantiv>}, \texttt{<eigenname>}, \texttt{<verb>} \} \)
	\item Terminale: \( \{ \texttt{Friedrich}, \texttt{Roland}, \texttt{der}, \texttt{die}, \texttt{das}, \texttt{liest}, \texttt{kauft}, \texttt{lernt}, \texttt{Buch}, \texttt{Schokolade}, \texttt{Informatik} \} \)
	\item Produktionsregeln:
	\[
	\begin{aligned}
		\texttt{<satz>} &\rightarrow \texttt{<subjekt><prädikat><objekt>} \\
		\texttt{<subjekt>} &\rightarrow \texttt{<eigenname>} \mid \texttt{<substantivgruppe>} \\
		\texttt{<substantivgruppe>} &\rightarrow \texttt{<artikel><substantiv>} \\
		\texttt{<prädikat>} &\rightarrow \texttt{<verb>} \\
		\texttt{<objekt>} &\rightarrow \texttt{<substantivgruppe>} \\
		\texttt{<verb>} &\rightarrow \texttt{liest} \mid \texttt{kauft} \mid \texttt{lernt} \\
		\texttt{<artikel>} &\rightarrow \texttt{der} \mid \texttt{die} \mid \texttt{das} \\
		\texttt{<eigenname>} &\rightarrow \texttt{Friedrich} \mid \texttt{Roland} \\
		\texttt{<substantiv>} &\rightarrow \texttt{Buch} \mid \texttt{Schokolade} \mid \texttt{Informatik}
	\end{aligned}
	\]
	\item Startsymbol: \texttt{<satz>}
\end{itemize}

\subsection*{Teilaufgaben:}

\begin{enumerate}
	\item Leiten Sie die folgenden Sätze mit der Grammatik ab:
	\begin{itemize}
		\item \texttt{Friedrich liest das Buch}
		\item \texttt{der Friedrich der das Buch liest}
	\end{itemize}
	
	\item Die Erweiterung der Grammatik, um Sätze wie \texttt{"der Friedrich der die Schokolade kauft"} zu akzeptieren, wäre aus Sicht einer formalen Sprache fehlerhaft.  
	Diskutieren Sie, in welchen Situationen es trotzdem sinnvoll sein könnte, solche Erweiterungen vorzunehmen, beispielsweise bei der Entwicklung von KI-gestützten Korrektur- oder Schreibprogrammen.
\end{enumerate}
	
	%\vspace{1cm}
	
	\newpage
	\section*{Lösungen}
	
	\section*{Lösung zu Aufgabe 1: Analyse eines Algorithmus}
	
	\begin{enumerate}
		\item \textbf{Funktionsweise:}  
		Der Algorithmus berechnet die Summe aller natürlichen Zahlen von \( n \) bis 1, also
		\[
		1 + 2 + 3 + \dotsb + n
		\]
		Es handelt sich um die Berechnung der sogenannten \emph{arithmetischen Reihe}.
		
		\item \textbf{Art der Implementierung:}  
		Die Implementierung ist \textbf{rekursiv}. Der Vorteil: der Code ist sehr kompakt und leicht verständlich.  
		Der Nachteil: bei sehr großen \( n \) kann ein \emph{Stack Overflow} auftreten, weil für jede Rekursionsstufe ein Funktionsaufruf auf dem Stack liegt.
		
		\item \textbf{Funktionsweise bei \( n = 5 \):}
		\[
		\begin{aligned}
			\texttt{berechne(5)} &= 5 + \texttt{berechne(4)} \\
			&= 5 + (4 + \texttt{berechne(3)}) \\
			&= 5 + (4 + (3 + \texttt{berechne(2)})) \\
			&= 5 + (4 + (3 + (2 + \texttt{berechne(1)}))) \\
			&= 5 + (4 + (3 + (2 + (1 + \texttt{berechne(0)})))) \\
			&= 5 + (4 + (3 + (2 + (1 + 0)))) \\
			&= 5 + (4 + (3 + (2 + 1))) \\
			&= 5 + (4 + (3 + 3)) \\
			&= 5 + (4 + 6) \\
			&= 5 + 10 \\
			&= 15
		\end{aligned}
		\]
		
		\item \textbf{Anzahl der Aufrufe:}  
		Für \texttt{berechne(5)} werden insgesamt 6 Aufrufe benötigt (für \( n = 5,4,3,2,1,0 \)).
		
		\item \textbf{Zeitkomplexität:}  
		Jeder Funktionsaufruf reduziert \( n \) um 1, also linear viele Aufrufe.  
		→ Zeitkomplexität: \( \mathcal{O}(n) \)
		
		\item \textbf{Vergleich zu iterativer Berechnung:}  
		Eine Schleife wie
		\begin{verbatim}
			int summe = 0;
			for (int i = 1; i <= n; i++) {
				summe += i;
			}
		\end{verbatim}
		benötigt ebenfalls \( \mathcal{O}(n) \) Zeit, aber keinen Rekursions-Stack und ist deshalb effizienter im Speicherverbrauch.
	\end{enumerate}
	
	\vspace{2em}
	
\section*{Lösung zu Aufgabe 2: Datenmodellierung und Normalisierung – SchulPortal}

\begin{enumerate}
	\item \textbf{Redundanzen und Anomalien:}
	
	\begin{itemize}
		\item \textbf{Redundanz:} 
		\begin{itemize}
			\item Die Daten eines Elternteils (z.\,B. Name, Telefonnummer) erscheinen mehrfach, wenn ein Elternteil mehreren Schülern zugeordnet ist.
			\item Die Adresse wird mehrfach gespeichert, obwohl sie logisch eine eigene Entität ist.
		\end{itemize}
		
		\item \textbf{Anomalien:}
		\begin{itemize}
			\item \emph{Änderungsanomalie:} Wenn sich die Telefonnummer eines Elternteils ändert, muss dies an mehreren Stellen manuell angepasst werden.
			\item \emph{Einfügeanomalie:} Ein neuer Elternteil kann nicht in das System aufgenommen werden, ohne einen verknüpften Schüler einzutragen.
			\item \emph{Löschanomalie:} Wird ein Schüler gelöscht, können auch wichtige Elterninformationen unbeabsichtigt verloren gehen.
		\end{itemize}
	\end{itemize}
	
	\vspace{1em}
	
	\item \textbf{Schrittweise Normalisierung bis zur 3. Normalform (3NF):}
	
	\subsubsection*{Schritt 1: 1. Normalform (1NF)}
	\begin{itemize}
		\item Die Spalte \texttt{Adresse} enthält zusammengesetzte Werte (Straße, Stadt, PLZ) und ist daher \textbf{nicht atomar}.
		\item Zur Erfüllung der 1NF müssen diese Bestandteile auf separate Attribute verteilt werden.
		\item \textbf{Ergebnis:} Nach Aufspaltung in \texttt{Straße}, \texttt{Stadt}, \texttt{PLZ} erfüllt die Tabelle die 1NF.
	\end{itemize}
	
	\vspace{0.5em}
	
	\subsubsection*{Schritt 2: 2. Normalform (2NF)}
	\begin{itemize}
		\item Die Ausgangstabelle enthält funktionale Abhängigkeiten, die nur von einem Teil des zusammengesetzten Primärschlüssels (SchuelerID, ElternID) abhängen.
		\item Beispiel: Vorname, Nachname, Klasse hängen nur von der SchuelerID ab.
		\item Zerlegung in separate Tabellen:
		\begin{itemize}
			\item \texttt{Schueler(\underline{SchuelerID}, Vorname, Nachname, AdresseID, Klasse)}
			\item \texttt{Elternteil(\underline{ElternID}, Name\_Elternteil, Telefonnummer)}
		\end{itemize}
		\item Einführung einer Zuordnungstabelle für n:m-Beziehungen:
		\begin{itemize}
			\item \texttt{SchuelerEltern(\underline{SchuelerID}, \underline{ElternID})}
		\end{itemize}
	\end{itemize}
	
	\vspace{0.5em}
	
	\subsubsection*{Schritt 3: 3. Normalform (3NF)}
	\begin{itemize}
		\item Die Adresse besteht noch aus mehreren Attributen (Straße, Stadt, PLZ), die zusammengehören, aber nicht direkt funktional von SchuelerID abhängen.
		\item Diese transitive Abhängigkeit wird durch eine separate Adresse-Tabelle beseitigt:
		\begin{itemize}
			\item \texttt{Adresse(\underline{AdresseID}, Straße, Stadt, PLZ)}
		\end{itemize}
		\item Die Adresse wird über einen Fremdschlüssel mit \texttt{Schueler} verknüpft:
		\begin{itemize}
			\item \texttt{Schueler(\underline{SchuelerID}, Vorname, Nachname, \textbf{AdresseID (FK)}, Klasse)}
		\end{itemize}
	\end{itemize}
	
	\vspace{1em}
	
	\textbf{Endgültige Tabellenstruktur mit Primär- und Fremdschlüsseln:}
	
	\begin{itemize}
		\item \texttt{Adresse(\underline{AdresseID}, Straße, Stadt, PLZ)}
		\item \texttt{Schueler(\underline{SchuelerID}, Vorname, Nachname, \textbf{AdresseID (FK)}, Klasse)}
		\item \texttt{Elternteil(\underline{ElternID}, Name\_Elternteil, Telefonnummer)}
		\item \texttt{SchuelerEltern(\underline{SchuelerID (FK)}, \underline{ElternID (FK)})}
	\end{itemize}
	
	\textit{(FK = Fremdschlüssel)}
	
	\vspace{1em}
	
	\item \textbf{Vorteile der Normalisierung:}
	\begin{itemize}
		\item \textbf{Redundanzfreiheit:} Daten wie Adresse oder Telefonnummer müssen nur einmal gespeichert werden.
		\item \textbf{Datenkonsistenz:} Änderungen an einer Stelle wirken sich automatisch korrekt aus.
		\item \textbf{Bessere Wartbarkeit:} Klare Trennung von Entitäten vereinfacht Erweiterungen.
		\item \textbf{Datenintegrität:} Fremdschlüsselbeziehungen sichern korrekte Verknüpfungen.
		\item \textbf{Flexibilität:} Mehrere Schüler können denselben Elternteil oder dieselbe Adresse referenzieren.
	\end{itemize}
\end{enumerate}

	
	
	\vspace{2em}
	
	\section*{Lösung zu Aufgabe 3: Analyse einer formalen Grammatik}
	
	\begin{enumerate}
		\item \textbf{Ableitungen:}
		\begin{itemize}
			\item \texttt{Friedrich liest das Buch:}
			\[
			\begin{aligned}
				\texttt{<satz>} &\Rightarrow \texttt{<subjekt><prädikat><objekt>} \\
				&\Rightarrow \texttt{<eigenname><prädikat><objekt>} \\
				&\Rightarrow \texttt{Friedrich <verb> <objekt>} \\
				&\Rightarrow \texttt{Friedrich liest <substantivgruppe>} \\
				&\Rightarrow \texttt{Friedrich liest <artikel><substantiv>} \\
				&\Rightarrow \texttt{Friedrich liest das Buch}
			\end{aligned}
			\]
			
			\item \texttt{der Friedrich der das Buch liest:}
			
			Keine korrekte Ableitung möglich:  
			-Artikel „der“ kann nicht vor Eigenname „Friedrich“ stehen.  
			-Struktur weicht ab: doppelter Artikel und falsche Reihenfolge.
		\end{itemize}
		
		\item \textbf{Sprachbeschreibung:}
		
		Die Grammatik erzeugt Sätze der Struktur:  
		\[
		\text{(Eigenname oder Artikel + Substantiv)} + \text{Verb} + (\text{Artikel + Substantiv})
		\]
		also einfache Sätze wie:
		- Friedrich liest das Buch
		- die Schokolade kauft der Roland
		
		(aber keine Relativsätze oder verschachtelten Konstruktionen.)
		
		\item \textbf{Diskussion KI und Erweiterung:}
		
		Formale Grammatiken verlangen eine strikt festgelegte Satzstruktur.  
		KI-gestützte Korrektur- oder Schreibprogramme müssen jedoch auch mit umgangssprachlichen, ungrammatischen oder verschachtelten Sätzen umgehen können.  
		Daher ist es sinnvoll, die Grammatik zu erweitern oder zu lockern, um:
		\begin{itemize}
			\item Eingabefehler besser zu erkennen und zu korrigieren
			\item Benutzerfreundlichkeit zu erhöhen
			\item realistische Alltagssprache zu verarbeiten
		\end{itemize}
	\end{enumerate}
	
	
\end{document}

